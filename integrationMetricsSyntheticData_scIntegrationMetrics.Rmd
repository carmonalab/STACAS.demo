---
title: "Test scIntegration metrics on synthetic data"
author: "S. Carmona"
output:
  rmdformats::readthedown:
    self-contained: true
    highlight: haddock
    thumbnails: false
    css: styles.css
knit: (function(input_file, encoding) {
  out_dir <- 'docs';
  rmarkdown::render(input_file, encoding=encoding,
 output_file=file.path(dirname(input_file), out_dir, 'test_metrics_syntheticData.html'))})
---

# Introduction
  
We are interested in evaluating integration of scRNA-seq datasets of heterogeneous cell type composition and batch size, which are typical in tumor samples.
Here we will test different metrics used to assess quality of data integration or batch effect removal on synthetic datasets generated with [splatter](https://bioconductor.org/packages/release/bioc/vignettes/splatter/inst/doc/splatter.html).
We will simulate datasets that can contain one or two of two possible cell types, with different levels of batch effects and relative batch sizes


# R environment

Get and load some useful packages
```{r message=F, warning=F,results=F, eval=T}
renv::restore()

if (!require("remotes", quietly = TRUE))
    install.packages("remotes")
library(remotes)

if (!require("tidyr", quietly = TRUE))
install.packages("tidyr")

if (!require("scIntegrationMetrics", quietly = TRUE))
install_github("carmonalab/scIntegrationMetrics") # calculates LISI, normalized LISI, LISI split by group, Silhouette, etc.

if (!requireNamespace("BiocManager"))
    install.packages("BiocManager")


```


```{r message=F, warning=F,results=F}
library(dplyr)
library(ggplot2)
library(tidyr)
library(scIntegrationMetrics)
library(patchwork)
library(Seurat)

seed = 1234
set.seed(seed)
```

```{r}
# Load required packages
suppressPackageStartupMessages({
    library(SingleCellExperiment)
    library(dplyr)
    library(purrr)
    library(ggplot2)
    library(scater)
})
```



# Load test datasets

Load synthetic datasets (batch effects + different subtype composition) to evaluate metrics

```{r}
object.list <- readRDS("batchCellTypes.synthetic.seurat.rds")
```


Annotated subtypes and dataset/study are stored in `functional.cluster` and `Study` metadata column, respectively.

```{r}
meta.batch <- "Batch"
meta.label <- "Group"
```


Set critical parameters
```{r}
nfeatures <- 500 # number of highly variable genes for dimensionality reduction
ndim <- 2 # number of PCA components for dimensionality reduction 
lisi_perplexity <- 20 # number of neighbors for LISI (see below for details) to measure batch mixing
```


```{r}
object.list <- sapply(object.list,function(object){
  object <- FindVariableFeatures(object, nfeatures = nfeatures) %>% ScaleData() %>% RunPCA(npcs=ndim)  
},USE.NAMES = T)
```

```{r}
p.list <- lapply(object.list,function(object){
  a <- DimPlot(object, group.by = meta.batch, reduction = "pca") | DimPlot(object, group.by = meta.label, reduction = "pca") 
  a & theme(aspect.ratio = 1)
})
p.list
```

Test with one object

```{r}
object <- object.list[[1]]
```

```{r}
batchLabels.table <- table(object@meta.data[[meta.label]], object@meta.data[[meta.batch]])
batchLabels.table
```

```{r}
integrationMetrics <- list()

method = "synthetic2celltypes"
method.reduction <- "pca"
metricsObject <- object

metrics <- c("batch_nLISI", "batch_nLISI_perCellType", "batch_nLISI_perCellType_means", 
"celltype_nLISI", "celltype_nLISI_means", "celltype_ASW", "celltype_ASW_means")

integrationMetrics[[method]] <- getIntegrationMetrics(metricsObject, metrics = metrics, meta.label, meta.batch, lisi_perplexity, method.reduction, metricsLabels = c("Group1","Group2")) 

integrationMetrics
```


Now let's do it for each dataset
```{r}

metrics <- NULL # by default, calculate all available metrics

integrationMetrics <- lapply(object.list,function(metricsObject){
 getIntegrationMetrics(metricsObject, metrics = metrics, meta.label, meta.batch, lisi_perplexity, method.reduction)
})
```



```{r, fig.width=8, fig.height=8}
plot.list <- list()

metricsShow.batch <- grep("batch",names(integrationMetrics[[1]]),value = T)

metricsShow.celltype <- grep("celltype",names(integrationMetrics[[1]]),value = T)



for (method in names(object.list)) {
  metricsObject <- object.list[[method]]

  metricsShow.batch.caption <- paste(metricsShow.batch,round(as.numeric(integrationMetrics[[method]][metricsShow.batch]),2),collapse = "\n ")
  metricsShow.celltype.caption <- paste(metricsShow.celltype,round(as.numeric(integrationMetrics[[method]][metricsShow.celltype]),2),collapse = "\n ")
    
  plot.list[[method]][["batch"]] <-
    DimPlot(metricsObject, group.by = meta.batch, reduction = "pca") + theme(aspect.ratio = 1) + labs(
      subtitle = "Dataset/batch",
      title = method,
      caption = metricsShow.batch.caption
        )
  
  plot.list[[method]][["label"]] <-
    DimPlot(
      metricsObject,
      group.by = meta.label,
      label = T,
      label.size = 4,
      reduction = "pca"
    ) + theme(aspect.ratio = 1) + labs(
      subtitle = "Cell labels",
      title = method,
      caption = metricsShow.celltype.caption
    )
  
  p <- plot.list[[method]][["batch"]] | plot.list[[method]][["label"]]
  
  print(p)
  
}


```


# Summary of Integration Metrics

```{r, fig.height=8, fig.width=8}

integrationMetricsSummary <- data.frame(unlist(integrationMetrics)) %>% tibble::rownames_to_column() %>% dplyr::rename(value=unlist.integrationMetrics.) %>% separate(rowname, c("Method","Metric"), sep="\\.")

ggplot(integrationMetricsSummary,aes(x=reorder(Method,-value), y=value, fill=Method)) + geom_bar(stat="identity") + 
    theme_bw() + 
    theme(legend.position="none", axis.text.x=element_text(angle = 90, vjust = 0.5, hjust=1)) + xlab("Dataset") + facet_wrap(~Metric, scales = "free")

```


```{r fig.height=10, fig.width=10}
p <- wrap_plots(lapply(plot.list,wrap_plots),ncol=2)
p & theme(legend.position = "none")
#ggsave("compareMetrics.umap.png",p, width = 30, height = 30)
```


