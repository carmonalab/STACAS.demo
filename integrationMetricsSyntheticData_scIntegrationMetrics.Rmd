---
title: "Test scIntegration metrics on synthetic data"
author: "S. Carmona"
output:
  rmdformats::readthedown:
    self-contained: true
    highlight: haddock
    thumbnails: false
    css: styles.css
knit: (function(input_file, encoding) {
  out_dir <- 'docs';
  rmarkdown::render(input_file, encoding=encoding,
 output_file=file.path(dirname(input_file), out_dir, 'test_CellMixS.html'))})
---

# Introduction
  
We are interested in evaluating integration of scRNA-seq datasets of heterogeneous cell type composition and batch size, which are typical in tumor samples.
Here we will test different metrics used to assess quality of data integration or batch effect removal on synthetic datasets generated with [splatter](https://bioconductor.org/packages/release/bioc/vignettes/splatter/inst/doc/splatter.html).
We will simulate datasets that can contain one or two of two possible cell types, with different levels of batch effects and relative batch sizes


# R environment

Get and load some useful packages
```{r message=F, warning=F,results=F, eval=T}
renv::restore()

if (!require("remotes", quietly = TRUE))
    install.packages("remotes")
library(remotes)

if (!require("tidyr", quietly = TRUE))
install.packages("tidyr")

if (!require("scIntegrationMetrics", quietly = TRUE))
install_github("carmonalab/scIntegrationMetrics") #calculates LISI and Silhouette

if (!requireNamespace("BiocManager"))
    install.packages("BiocManager")


```


```{r message=F, warning=F,results=F}
library(dplyr)
library(ggplot2)
library(tidyr)
library(scIntegrationMetrics)
library(patchwork)
library(Seurat)

seed = 1234
set.seed(seed)
```

```{r}
# Load required packages
suppressPackageStartupMessages({
    library(SingleCellExperiment)
    library(dplyr)
    library(purrr)
    library(ggplot2)
    library(scater)
})
```



```{r}
getIntegrationMetrics <- function(metricsObject, meta.label, meta.batch, lisi_perplexity, method.reduction, metricsLabels=NULL){

integrationMetrics <- list()

if(is.null(metricsLabels)) metricsLabels <- levels(metricsObject@meta.data[[meta.label]])
message(paste("Cell type labels:",paste(metricsLabels,collapse = ",")))
    
metricsLabels_logic <- metricsObject@meta.data[[meta.label]] %in% metricsLabels
batchNames <- levels(metricsObject@meta.data[[meta.batch]])
message(paste("Batches:",paste(batchNames,collapse = ",")))

#batch lisi
lisi.this <- compute_lisi(metricsObject@reductions[[method.reduction]]@cell.embeddings, meta_data = metricsObject@meta.data, label_colnames=meta.batch, perplexity = lisi_perplexity)[[1]]

lisi.this.normalized <- (lisi.this-1)/(length(batchNames)-1)

integrationMetrics[["batch_nLISI"]] <- mean(lisi.this.normalized[metricsLabels_logic]) 
#integrationMetrics[["batch_nLISI_means"]] <- mean(tapply(lisi.this.normalized,metricsObject@meta.data[[meta.label]],mean)[metricsLabels]) #means per cell type

#batch lisi per celltype 
lisi_splitByCelltype <- compute_lisi_splitBy(metricsObject@reductions[[method.reduction]]@cell.embeddings, meta_data = metricsObject@meta.data, label_colnames=meta.batch, perplexity = lisi_perplexity, split_by_colname=meta.label, normalize = T)

integrationMetrics[["batch_nLISI_perCellType"]] <- mean(unlist(lisi_splitByCelltype))
classMeans <- sapply(lisi_splitByCelltype,mean)
message("batch_nLISI_perCellType: ",paste(names(lisi_splitByCelltype),round(classMeans,2)," "))
integrationMetrics[["batch_nLISI_perCellType_means"]] <- mean(classMeans)

#cluster/celltype lisi
lisi.this <- compute_lisi(metricsObject@reductions[[method.reduction]]@cell.embeddings, meta_data = metricsObject@meta.data, label_colnames=meta.label, perplexity = lisi_perplexity)[[1]]

lisi.this.normalized <- (lisi.this-1)/(length(metricsLabels)-1)

integrationMetrics[["celltype_nLISI"]] <- mean(lisi.this.normalized[metricsLabels_logic]) 
integrationMetrics[["celltype_nLISI_means"]] <- mean(tapply(lisi.this.normalized,metricsObject@meta.data[[meta.label]],mean)[metricsLabels])

# silhouette

sil.this <- compute_silhouette(metricsObject@reductions[[method.reduction]]@cell.embeddings, meta_data = metricsObject@meta.data, label_colnames=meta.label)[[1]]

integrationMetrics[["celltype_ASW"]] <- mean(sil.this[metricsLabels_logic])
integrationMetrics[["celltype_ASW_means"]] <- mean(tapply(sil.this,metricsObject@meta.data[[meta.label]],mean)[metricsLabels])

return(integrationMetrics)

}
```



# Load test datasets

Load synthetic datasets (batch effects + different subtype composition) to evaluate metrics

```{r}
object.list <- readRDS("batchCellTypes.synthetic.seurat.rds")
```


Annotated subtypes and dataset/study are stored in `functional.cluster` and `Study` metadata column, respectively.

```{r}
meta.batch <- "Batch"
meta.label <- "Group"
```


Set critical parameters
```{r}
nfeatures <- 500 # number of highly variable genes for dimensionality reduction
ndim <- 2 # number of PCA components for dimensionality reduction 
lisi_perplexity <- 20 # number of neighbors for LISI (see below for details) to measure batch mixing
```


```{r}
object.list <- sapply(object.list,function(object){
  object <- FindVariableFeatures(object, nfeatures = nfeatures) %>% ScaleData() %>% RunPCA(npcs=ndim)  
},USE.NAMES = T)
```

```{r}
p.list <- lapply(object.list,function(object){
  a <- DimPlot(object, group.by = meta.batch, reduction = "pca") | DimPlot(object, group.by = meta.label, reduction = "pca") 
  a & theme(aspect.ratio = 1)
})
p.list
```

Test with one object

```{r}
object <- object.list[[1]]
```

```{r}
batchLabels.table <- table(object@meta.data[[meta.label]], object@meta.data[[meta.batch]])
batchLabels.table
```

```{r}
batchLabels <- round( batchLabels.table / rowSums(batchLabels.table) * 100) 
batchLabels
thrMaxPerBatch <- 90
minBatchesPerCellType <- 2
thrMinPerBatch <- 5
```

```{r}
bachesPerLabel <- apply(batchLabels,1,function(x) sum(x > thrMinPerBatch) )
removeLabels <- names(bachesPerLabel[bachesPerLabel < minBatchesPerCellType ])
removeLabels <- unique(removeLabels,names(which(apply(batchLabels, 1, function(x) max(x) > thrMaxPerBatch) ))) #  contributed in more than 90% by a single dataset/batch
removeLabels
metricsLabels <- setdiff(unique(object@meta.data[[meta.label]]),removeLabels)
```

```{r}
integrationMetrics <- list()

method = "uncorrected"
method.reduction <- "pca"
metricsObject <- object

integrationMetrics[[method]] <- getIntegrationMetrics(metricsObject, meta.label, meta.batch, lisi_perplexity, method.reduction, metricsLabels = metricsLabels)
```


Now let's do it for each dataset
```{r}

integrationMetrics <- lapply(object.list,function(metricsObject){
 getIntegrationMetrics(metricsObject, meta.label, meta.batch, lisi_perplexity, method.reduction, metricsLabels = metricsLabels)
})
```
```{r}
metricsShow <- c("batch_nLISI", "batch_nLISI_perCellType", "batch_nLISI_perCellType_means", 
"celltype_nLISI", "celltype_nLISI_means", "celltype_ASW", "celltype_ASW_means")
```


```{r, fig.width=12, fig.height=5}
plot.list <- list()

metricsShow.batch <- grep("batch",metricsShow,value = T)

metricsShow.celltype <- grep("celltype",metricsShow,value = T)



for (method in names(object.list)) {
  metricsObject <- object.list[[method]]

  metricsShow.batch.caption <- paste(metricsShow.batch,round(as.numeric(integrationMetrics[[method]][metricsShow.batch]),2),collapse = "; ")
  metricsShow.celltype.caption <- paste(metricsShow.celltype,round(as.numeric(integrationMetrics[[method]][metricsShow.celltype]),2),collapse = "; ")
    
  plot.list[[method]][["batch"]] <-
    DimPlot(metricsObject, group.by = meta.batch, reduction = "pca") + theme(aspect.ratio = 1) + labs(
      subtitle = "Dataset/batch",
      title = method,
      caption = metricsShow.batch.caption
        )
  
  plot.list[[method]][["label"]] <-
    DimPlot(
      metricsObject,
      group.by = meta.label,
      label = T,
      label.size = 4,
      reduction = "pca"
    ) + theme(aspect.ratio = 1) + labs(
      subtitle = "Cell labels",
      title = method,
      caption = metricsShow.celltype.caption
    )
  
  p <- plot.list[[method]][["batch"]] | plot.list[[method]][["label"]]
  
  print(p)
  
}


```


# Summary of Integration Metrics

```{r, fig.height=8, fig.width=8}

integrationMetricsSummary <- data.frame(unlist(integrationMetrics)) %>% tibble::rownames_to_column() %>% dplyr::rename(value=unlist.integrationMetrics.) %>% separate(rowname, c("Method","Metric"), sep="\\.")

ggplot(integrationMetricsSummary,aes(x=reorder(Method,-value), y=value, fill=Method)) + geom_bar(stat="identity") + 
    theme_bw() + 
    theme(legend.position="none", axis.text.x=element_text(angle = 90, vjust = 0.5, hjust=1)) + xlab("Dataset") + facet_wrap(~Metric, scales = "free")

```


```{r fig.height=10, fig.width=10}
p <- wrap_plots(lapply(plot.list,wrap_plots),ncol=2)
p & theme(legend.position = "none")
#ggsave("compareMetrics.umap.png",p, width = 30, height = 30)
```


