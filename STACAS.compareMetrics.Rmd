---
title: "Data integration with STACAS"
author: "M. Andreatta and S. Carmona"
date: "12/04/2022"
output:
  rmdformats::readthedown:
    self-contained: true
    highlight: haddock
    thumbnails: false
    css: styles.css
knit: (function(input_file, encoding) {
  out_dir <- 'docs';
  rmarkdown::render(input_file, encoding=encoding,
 output_file=file.path(dirname(input_file), out_dir, 'STACAS.demo.html'))})
---

# Introduction

Here we will compare integration results of STACAS with other R packages on a collection of scRNA-seq datasets of immune cells from multiple donors, human tissues and studies, assembled by [Luecken et al.](https://www.nature.com/articles/s41592-021-01336-8) 

Here we compare vs Seurat v3 RPCA (upon which STACAS builds), the fast [HARMONY](https://github.com/immunogenomics/harmony), and [FastMNN](https://bioconductor.org/packages/release/bioc/html/batchelor.html) that ranked first (together with Python's Scanorama) for this task in the excellent benchmark by [Luecken et al.](https://theislab.github.io/scib-reproducibility/dataset_immune_cell_hum.html#12_Table).

The data are available at: [figshare/12420968](https://figshare.com/articles/dataset/Benchmarking_atlas-level_data_integration_in_single-cell_genomics_-_integration_task_datasets_Immune_and_pancreas_/12420968)


# R environment

Get and load some useful packages
```{r message=F, warning=F,results=F, eval=T}
renv::restore()

if (!require("remotes", quietly = TRUE))
    install.packages("remotes")
library(remotes)

if (!requireNamespace("STACAS", quietly = TRUE))
  remotes::install_github("carmonalab/STACAS")

if (!requireNamespace("harmony", quietly = TRUE))
  remotes::install_github("immunogenomics/harmony")

if (!requireNamespace("SeuratWrappers", quietly = TRUE))
remotes::install_github('satijalab/seurat-wrappers')

if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

if (!require("batchelor", quietly = TRUE))
BiocManager::install("batchelor")

```


```{r message=F, warning=F,results=F}
library(Seurat)
library(dplyr)
library(ggplot2)
library(STACAS)
library(harmony)
library(SeuratWrappers)
library(batchelor)

seed = 1234
set.seed(seed)
```


# Load test datasets

Download the dataset of human immune cells assembled by [Luecken et al.](https://www.nature.com/articles/s41592-021-01336-8), and convert them to Seurat objects.
```{r}
download <- F
where <- 'aux'
dir.create(where, showWarnings = FALSE)

rds.path <- sprintf("%s/Immune_ALL_human.rds", where)

if(download){

  options(timeout=500)
  url <- "https://figshare.com/ndownloader/files/25717328"
  h5.path <- sprintf("%s/Immune_ALL_human.rds", where)
  download.file(url = url, destfile = h5.path)
  
  if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

  if (!require("zellkonverter", quietly = TRUE))
    install.packages("zellkonverter") # to convert from h5ad to R object
  
  #Convert to Seurat 
  object.sce <- zellkonverter::readH5AD(h5.path)
  object <- Seurat::as.Seurat(object.sce, counts = "counts", data = "X")
  object <- RenameAssays(object, originalexp="RNA")
  rm (object.sce)
  
  Idents(object) <- "final_annotation"
  saveRDS(object = object,file = rds.path)

}else{
  object <- readRDS(rds.path)
}
```

Cell types were annotated by the authors on each dataset individually, using a common dictionary of cell types (see https://github.com/theislab/scib-reproducibility).
These are stored in the `final_annotation` metadata column. Study of origin is stored in `batch` metadaa

```{r}
table(object$final_annotation, object$batch)[,1:5]
```

How does the collection of datasets look without any integration?

Run a standard Seurat pipeline for dimensionality reduction


```{r message=F, warning=F,results=F}
nfeatures <- 1000
ndim <- 20
object <- FindVariableFeatures(object, nfeatures = nfeatures) %>% NormalizeData() %>% ScaleData() %>% RunPCA(npcs=ndim) %>% RunUMAP(dims=1:ndim)
```

```{r fig.height=7, fig.width=16}
p1_pre <- DimPlot(object, group.by = "batch") + theme(aspect.ratio = 1) + ggtitle("Dataset/batch before integration")
p2_pre <- DimPlot(object, group.by = "final_annotation", label=T, label.size = 4) + theme(aspect.ratio = 1) + ggtitle("Cell labels before integration")


p1_pre | p2_pre
```

Although cells mostly cluster by the cell type (as annotated in individual datasets), there are also visible batch effects (seen as dataset-specific clustering) 


Let's quantify dataset/batch mixing using the [LISI metric](https://github.com/immunogenomics/LISI) from the Raychaudhuri Lab, and conservation of biological information by means of Average Silhouette Width (ASW) of cell labels in the corrected PCA space:
```{r}

integrationMetrics <- list()

if (!require("scIntegrationMetrics", quietly = TRUE))
install_github("carmonalab/scIntegrationMetrics") #calculates LISI and Silhouette
library(scIntegrationMetrics)
lisi_perplexity <- 20

integrationMetrics[["uncorrected"]] <- list()

integrationMetrics[["uncorrected"]][["batch_LISI"]] <- mean(compute_lisi(object@reductions[["pca"]]@cell.embeddings, meta_data = object@meta.data, label_colnames="batch", perplexity = lisi_perplexity)[[1]]) # perplexity=effective number of each cell's neighbors; use lower than default to make it faster

integrationMetrics[["uncorrected"]][["celltype_ASW"]] <- mean(compute_silhouette(object@reductions[["pca"]]@cell.embeddings, meta_data = object@meta.data, label_colnames="final_annotation")[[1]])

integrationMetrics[["uncorrected"]]

```



We will now apply STACAS for correcting batch effects.

# STACAS integration

The previous integration could have been run from the initial object with a single command:
```{r}

obj.list <- SplitObject(object, split.by = "batch")

object_integrated <- Run.STACAS(obj.list, dims = 1:ndim, anchor.features = nfeatures) %>%
      RunUMAP(dims = 1:ndim) 

DimPlot(object_integrated, group.by = "batch")
```


```{r fig.height=7, fig.width=16}
p1_int <- DimPlot(object_integrated, group.by = "batch") + theme(aspect.ratio = 1) + ggtitle("Dataset/batch after integration")
p2_int <- DimPlot(object_integrated, group.by = "final_annotation", label=T, label.size = 2) + theme(aspect.ratio = 1) + ggtitle("Cell labels after integration") 

p1_int | p2_int
```


**Quantify integration metrics**:
```{r}
integrationMetrics[["STACAS"]] <- list()

integrationMetrics[["STACAS"]][["batch_LISI"]] <- mean(compute_lisi(object_integrated@reductions[["pca"]]@cell.embeddings, meta_data = object@meta.data, label_colnames="batch", perplexity = lisi_perplexity)[[1]])

integrationMetrics[["STACAS"]][["celltype_ASW"]] <- mean(compute_silhouette(object_integrated@reductions[["pca"]]@cell.embeddings, meta_data = object@meta.data, label_colnames="final_annotation")[[1]])

integrationMetrics[["STACAS"]]
```


# Semi-supervised STACAS integration

When available, cell type annotations can be used to guide the alignment. STACAS will use this information to penalize anchors where cell types are inconsistent.
In this dataset, cells were annotated by the authors of the benchmark. In practice we will partially annotate cells using tools such as [scGate](https://github.com/carmonalab/scGate)

Here we indicate in `cell.labels` the metadata column that contains cell annotations
```{r, results=F, warning=F, message=F }
object_integrated_ss <- obj.list %>% Run.STACAS(dims = 1:ndim, anchor.features = nfeatures, cell.labels = "final_annotation" )
```


Note that there is no need for ALL cells to be annotated: we recommend to set labels to *NA* or *unknown* for cells that cannot be confidently annotated, and they won't be penalized for label inconsistency. In addition, you can decide how much weight to give to cell labels with the `label.confidence` parameter (from 0 to 1).

Visualize on UMAP space
```{r results=F, warning=F, message=F}
object_integrated_ss <- object_integrated_ss %>% RunUMAP(dims=1:ndim)
```

```{r fig.height=7, fig.width=16}
p1_ss <- DimPlot(object_integrated_ss, group.by = "batch") + theme(aspect.ratio = 1) + ggtitle("Dataset/batch after semi-supervised integration")
p2_ss <- DimPlot(object_integrated_ss, group.by = "final_annotation", label=T, label.size = 2) + theme(aspect.ratio = 1) + ggtitle("Cell labels after semi-supervised integration")

p1_ss | p2_ss
```



**Quantify integration metrics**:
```{r}
integrationMetrics[["semisupSTACAS"]] <- list()

integrationMetrics[["semisupSTACAS"]][["batch_LISI"]] <- mean(compute_lisi(object_integrated_ss@reductions[["pca"]]@cell.embeddings, meta_data = object@meta.data, label_colnames="batch", perplexity = lisi_perplexity)[[1]])

integrationMetrics[["semisupSTACAS"]][["celltype_ASW"]] <- mean(compute_silhouette(object_integrated_ss@reductions[["pca"]]@cell.embeddings, meta_data = object@meta.data, label_colnames="final_annotation")[[1]])

integrationMetrics[["semisupSTACAS"]]
```

In this case, by using the semi-supervised approach we observe a gain in biological signal conservation, as measured by cell labels silhouette (celltype_ASW), with a similar dataset/batch mixing (batch_LISI) compared to the unsupervised integration.


Seurat Integration - CCA method
```{r, results=F, warning=F, message=F, eval=F }

# find anchors
obj.list.seuratAnchors <- FindIntegrationAnchors(obj.list, anchor.features = nfeatures, reduction = "cca", dims = 1:ndim)

# integrate data
object_integrated_cca <- IntegrateData(anchorset = obj.list.seuratAnchors, dims=1:ndim)

rm(obj.list.seuratAnchors)
```

Visualize on UMAP space
```{r results=F, warning=F, message=F, eval=F}
object_integrated_cca <- object_integrated_cca %>% ScaleData() %>% RunPCA(npcs=ndim) %>% RunUMAP(dims=1:ndim)
```

```{r fig.height=7, fig.width=16, eval=F}
p1_cca <- DimPlot(object_integrated_cca, group.by = "batch") + theme(aspect.ratio = 1) + ggtitle("Dataset/batch after Seurat CCA integration")
p2_cca <- DimPlot(object_integrated_cca, group.by = "final_annotation", label=T, label.size = 2) + theme(aspect.ratio = 1) + ggtitle("Cell labels after Seurat CCA integration")

p1_cca | p2_cca
```

**Quantify integration metrics**:
```{r, eval=F}
integrationMetrics[["SEURAT_cca"]] <- list()

integrationMetrics[["SEURAT_cca"]][["batch_LISI"]] <- mean(compute_lisi(object_integrated_cca@reductions[["pca"]]@cell.embeddings, meta_data = object@meta.data, label_colnames="batch", perplexity = lisi_perplexity)[[1]])

integrationMetrics[["SEURAT_cca"]][["celltype_ASW"]] <- mean(compute_silhouette(object_integrated_cca@reductions[["pca"]]@cell.embeddings, meta_data = object@meta.data, label_colnames="final_annotation")[[1]])

integrationMetrics[["SEURAT_cca"]]
```

Seurat Integration - RPCA method
(we're skippin Seurat's default CCA method because it's very slow and it ranked lower than RPCA in https://theislab.github.io/scib-reproducibility/dataset_immune_cell_hum.html#12_Table)

```{r, results=F, warning=F, message=F }

# find anchors
obj.list.seuratAnchors <- FindIntegrationAnchors(obj.list, anchor.features = nfeatures, reduction = "rpca", dims = 1:ndim)
#obj.list.seuratAnchors <- FindIntegrationAnchors(obj.list, anchor.features = nfeatures, reduction = "cca", dims = 1:ndim)

# integrate data
object_integrated_rpca <- IntegrateData(anchorset = obj.list.seuratAnchors, dims=1:ndim)

rm(obj.list.seuratAnchors)
```

Visualize on UMAP space
```{r results=F, warning=F, message=F}

object_integrated_rpca <- object_integrated_rpca %>% ScaleData() %>% RunPCA(npcs=ndim) %>% RunUMAP(dims=1:ndim)
```

```{r fig.height=7, fig.width=16}
p1_rpca <- DimPlot(object_integrated_rpca, group.by = "batch") + theme(aspect.ratio = 1) + ggtitle("Dataset/batch after Seurat RPCA integration")
p2_rpca <- DimPlot(object_integrated_rpca, group.by = "final_annotation", label=T, label.size = 2) + theme(aspect.ratio = 1) + ggtitle("Cell labels after Seurat RPCA integration")

p1_rpca | p2_rpca
```

**Quantify integration metrics**:
```{r}
integrationMetrics[["SEURAT_RPCA"]] <- list()

integrationMetrics[["SEURAT_RPCA"]][["batch_LISI"]] <- mean(compute_lisi(object_integrated_rpca@reductions[["pca"]]@cell.embeddings, meta_data = object@meta.data, label_colnames="batch", perplexity = lisi_perplexity)[[1]])

integrationMetrics[["SEURAT_RPCA"]][["celltype_ASW"]] <- mean(compute_silhouette(object_integrated_rpca@reductions[["pca"]]@cell.embeddings, meta_data = object@meta.data, label_colnames="final_annotation")[[1]])

integrationMetrics[["SEURAT_RPCA"]]
```


Harmony Integration

#object has already pre-computed `nfeatures` variable genes and `ndim` PCA dimensions
```{r}
object_integrated_harmony <- RunHarmony(object, "batch")
```

Visualize on UMAP space
```{r results=F, warning=F, message=F}
object_integrated_harmony <- RunUMAP(object_integrated_harmony, reduction = "harmony", dims=1:ndim)
```

```{r fig.height=7, fig.width=16}
p1_h <- DimPlot(object_integrated_harmony, group.by = "batch") + theme(aspect.ratio = 1) + ggtitle("Dataset/batch after Harmony integration")
p2_h <- DimPlot(object_integrated_harmony, group.by = "final_annotation", label=T, label.size = 2) + theme(aspect.ratio = 1) + ggtitle("Cell labels after Harmony integration")

p1_h | p2_h
```


**Quantify integration metrics**:
```{r}
integrationMetrics[["Harmony"]] <- list()

integrationMetrics[["Harmony"]][["batch_LISI"]] <- mean(compute_lisi(object_integrated_harmony@reductions[["pca"]]@cell.embeddings, meta_data = object@meta.data, label_colnames="batch", perplexity = lisi_perplexity)[[1]])

integrationMetrics[["Harmony"]][["celltype_ASW"]] <- mean(compute_silhouette(object_integrated_harmony@reductions[["pca"]]@cell.embeddings, meta_data = object@meta.data, label_colnames="final_annotation")[[1]])

integrationMetrics[["Harmony"]]
```



FastMNN Integration
```{r, eval=F}
anchor.features <- SelectIntegrationFeatures(obj.list, nfeatures = nfeatures)
object_integrated_FastMNN <- RunFastMNN(obj.list, features = anchor.features, assay="RNA", d=ndims)
```




# Summary of Integration Metrics


```{r}
if (!require("tidyr", quietly = TRUE))
install.packages("tidyr")

integrationMetricsSummary <- data.frame(unlist(integrationMetrics)) %>% tibble::rownames_to_column() %>% rename(value=unlist.integrationMetrics.) %>% separate(rowname, c("Method","Metric"), sep="\\.")

a <- integrationMetricsSummary %>% filter(Metric=="batch_LISI") %>%
  ggplot(aes(x=Method, y=value, fill=Method)) + geom_bar(stat="identity") + 
  ggtitle("batch_LISI") + theme_bw() +
  theme(legend.position="none", axis.text.x=element_blank())
  

b <- integrationMetricsSummary %>% filter(Metric=="celltype_ASW") %>%
  ggplot(aes(x=Method, y=value, fill=Method)) + geom_bar(stat="identity") + 
  ggtitle("celltype_ASW") + theme_bw() +
  theme(axis.text.x=element_blank()) 
  
a | b
```





# Note

The calculation of highly variable genes (HVG) is a fundamental step for dimensionality reduction (and for integration based on low dimensional representations). We recommend excluding certain classes of genes, e.g. mitochondrial, ribosomal, heat-shock genes, from the list of variable genes, as their expression may be more related to technical variabilites rather than to cell type identity. The `FindVariableGenes.STACAS()` function allows providing a list of genes to exclude from HVG; see an example below.

We can use the collection of signatures stored in SignatuR package
```{r eval=F}
remotes::install_github("https://github.com/carmonalab/SignatuR")
```

```{r}
library(SignatuR)
print(SignatuR$Hs)
```

Then we can calculate HVG for STACAS excluding specific gene sets
```{r warning=F, collapse =T,message =F, eval=F}
my.genes.blocklist <- c(GetSignature(SignatuR$Hs$Blocklists),
                        GetSignature(SignatuR$Hs$Programs),
                        GetSignature(SignatuR$Hs$Compartments))

obj.list <- lapply(obj.list, function(x) {
    FindVariableFeatures.STACAS(x, nfeat = 2000, genesBlockList = my.genes.blocklist)

})

anchor.features <- SelectIntegrationFeatures(obj.list, nfeatures = nIntFeatures)
```

# Further reading

The STACAS package and installation instructions are available at: [STACAS package](https://github.com/carmonalab/STACAS)

The code for this demo can be found on [GitHub](https://github.com/carmonalab/STACAS.demo)

# References

* Andreatta A., Carmona S. J. (2021). *STACAS: Sub-Type Anchor Correction for Alignment in Seurat to integrate single-cell RNA-seq data.* - Bioinformatics

* Luecken, M. D., Büttner, M., Chaichoompu, K., Danese, A., Interlandi, M., Müller, M. F., ... & Theis, F. J. (2022). *Benchmarking atlas-level data integration in single-cell genomics.* - Nature methods

* Hao, Y., Hao, S., Andersen-Nissen, E., Mauck III, W. M., Zheng, S., Butler, A., ... & Satija, R. (2021). *Integrated analysis of multimodal single-cell data.* - Cell


