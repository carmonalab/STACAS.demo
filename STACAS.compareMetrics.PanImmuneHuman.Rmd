---
title: "STACAS vs other integration methods on broad immmune cell benchmark dataset"
author: "M. Andreatta and S. Carmona"
date: "26/08/2022"
output:
  rmdformats::readthedown:
    self-contained: true
    highlight: haddock
    thumbnails: false
    css: styles.css
knit: (function(input_file, encoding) {
  out_dir <- 'docs';
  rmarkdown::render(input_file, encoding=encoding,
 output_file=file.path(dirname(input_file), out_dir, 'STACAS.compareMethods.PanImmune.html'))})
---

# Introduction

Here we compare integration results of STACAS with other R packages on a collection of scRNA-seq datasets of immune cells from multiple donors, human tissues and studies, assembled by [Luecken et al.](https://www.nature.com/articles/s41592-021-01336-8) 

This comparison includes Seurat v3 (RPCA and CCA modes), [HARMONY](https://github.com/immunogenomics/harmony), and [FastMNN](https://bioconductor.org/packages/release/bioc/html/batchelor.html) that ranked first (together with Python's Scanorama) for this task in the excellent benchmark by [Luecken et al.](https://theislab.github.io/scib-reproducibility/dataset_immune_cell_hum.html#12_Table).

To evaluate integration quality we use different metrics that consider two aspects of integration: i) batch mixing of cells, and ii) conservation of biological signal. 
For i) we use batch LISI (bLISI, aka iLISI). Also, because batch-mixing of cells of different type is not desirable, we include a variation "per celltype batch LISI" or cbLISI) that only evaluates mixing of cells of the same type.

For ii) we use the average silhouette width (AWS; aka silhouette coefficient) , that measures the relationship between the within-cluster (i.e. intra-celltype) distances of a cell and the between-cluster (i.e. inter-celltype) distances of that cell to the closest cluster/cell type. We also evaluate cluster/celltype LISI (cLISI).

To calculate metrics here we used euclidean distances in the batch-corrected principal components analysis (PCA) space, but other low dimensional representations with meaninful distances could be used. 

The metrics are evaluated in the integrated data using different methods, and in the combined data without integration/batch correction.

The data are available at: [figshare/12420968](https://figshare.com/articles/dataset/Benchmarking_atlas-level_data_integration_in_single-cell_genomics_-_integration_task_datasets_Immune_and_pancreas_/12420968)


# R environment

Get and load some useful packages
```{r message=F, warning=F,results=F, eval=T}
renv::restore()

if (!require("remotes", quietly = TRUE))
    install.packages("remotes")
library(remotes)

if (!requireNamespace("STACAS", quietly = TRUE))
  remotes::install_github("carmonalab/STACAS")

if (!requireNamespace("harmony", quietly = TRUE))
  remotes::install_github("immunogenomics/harmony", ref="6866e01") #fix version at Sep 8, 2022

if (!requireNamespace("SeuratWrappers", quietly = TRUE))
remotes::install_github('satijalab/seurat-wrappers')

if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

if (!require("batchelor", quietly = TRUE))
BiocManager::install("batchelor")

if (!require("tidyr", quietly = TRUE))
install.packages("tidyr")

if (!require("tidytext", quietly = TRUE))
install.packages("tidytext")


if (!require("scIntegrationMetrics", quietly = TRUE))
install_github("carmonalab/scIntegrationMetrics") #calculates LISI and Silhouette

```


```{r message=F, warning=F,results=F}
library(Seurat)
library(dplyr)
library(ggplot2)
library(STACAS)
library(harmony)
library(SeuratWrappers)
library(batchelor)
library(tidyr)
library(scIntegrationMetrics)
library(patchwork)

seed = 1234
set.seed(seed)
```


# Load test datasets

Download the dataset of human immune cells assembled by [Luecken et al.](https://www.nature.com/articles/s41592-021-01336-8), and convert them to Seurat objects.
```{r}
download <- F
where <- 'aux'
dir.create(where, showWarnings = FALSE)

rds.path <- sprintf("%s/Immune_ALL_human.rds", where)

if(download){

  options(timeout=500)
  url <- "https://figshare.com/ndownloader/files/25717328"
  h5.path <- sprintf("%s/Immune_ALL_human.rds", where)
  download.file(url = url, destfile = h5.path)

  if (!require("zellkonverter", quietly = TRUE))
    install.packages("zellkonverter") # to convert from h5ad to R object
  
  #Convert to Seurat 
  object.sce <- zellkonverter::readH5AD(h5.path)
  object <- Seurat::as.Seurat(object.sce, counts = "counts", data = "X")
  object <- RenameAssays(object, originalexp="RNA")
  rm (object.sce)
  
  Idents(object) <- "final_annotation"
  saveRDS(object = object,file = rds.path)

}else{
  object <- readRDS(rds.path)
}
```


Cell types were annotated by the authors on each dataset individually, using a common dictionary of cell types (see https://github.com/theislab/scib-reproducibility).
These are stored in the `final_annotation` metadata column. Study of origin is stored in `batch` metadaa

```{r}
meta.batch <- "batch"
meta.label <- "final_annotation"
```


```{r}
batchLabels.table <- table(object@meta.data[[meta.label]], object@meta.data[[meta.batch]])
batchLabels.table
```


Optionally, for fast testing we can downsample cells in each batch
```{r}
downsample <- 3000

if(!is.null(downsample)){
  
  table(object@meta.data[[meta.batch]])
  table(object@meta.data[[meta.label]])
  
  Idents(object) <- meta.label
  object <- subset(object, downsample = downsample)
  
  Idents(object) <- meta.batch
  object <- subset(object, downsample = downsample)
  
  table(object@meta.data[[meta.batch]])
  table(object@meta.data[[meta.label]])
  
  batchLabels.table <- table(object@meta.data[[meta.label]],
                             object@meta.data[[meta.batch]])
  batchLabels.table
}
```


For integration metrics, do not consider labels that come from a single dataset/batch for `thrMaxPerBatch` (90%) of the total cells.

Additionally, at least `minBatchesPerCellType` (2) datasets have to contribute to the cell type with at least `thrMinPerBatch` (5%) of cells. The number of datasets over this threshold can be used to normalized LISI scores per label.

```{r}
batchLabels <- round( batchLabels.table / rowSums(batchLabels.table) * 100) 
thrMaxPerBatch <- 90
minBatchesPerCellType <- 2
thrMinPerBatch <- 5
```

```{r}
bachesPerLabel <- apply(batchLabels,1,function(x) sum(x > thrMinPerBatch) )
removeLabels <- names(bachesPerLabel[bachesPerLabel < minBatchesPerCellType ])
removeLabels <- unique(removeLabels,
                       names(which(apply(
                         batchLabels, 1, function(x) max(x) > thrMaxPerBatch)
                         ))) #  contributed in more than 90% by a single dataset/batch

metricsLabels <- setdiff(unique(object@meta.data[[meta.label]]),removeLabels)
if (length(removeLabels)>0) sprintf("Removed label: %s",removeLabels)
```


Parameters
```{r}
nfeatures <- 2000 # number of highly variable genes for dimensionality reduction
ndim <- 20 # number of PCA components for dimensionality reduction 
lisi_perplexity <- 30 # effective number of each cell's neighbors for LISI calculation to measure batch mixing
```

NOTE: In the Luecken's benchamark, 2000 HVG, 30 PCA dimensions (Seurat's default), and LISI perplexity=30 are used ([code](https://github.com/theislab/scib-pipeline/blob/main/scripts/integration/integration.R)).
We can use lower values for faster computation, with similar results


# How does the collection of datasets look without any integration?

Run a standard Seurat pipeline for dimensionality reduction

```{r message=F, warning=F,results=F}
object <- NormalizeData(object,normalization.method = "LogNormalize",
                        scale.factor = 10000) # these data are pre-normalized
object <- FindVariableFeatures(object, nfeatures = nfeatures) %>%
  ScaleData() %>%
  RunPCA(npcs=ndim) %>%
  RunUMAP(dims=1:ndim)
```


```{r}
integrationMetrics <- list()
useMetrics <- c("batch_LISI","batch_nLISI", "batch_nLISI_perCellType",
                "batch_nLISI_perCellType_means", "1-celltype_nLISI",
                "1-celltype_nLISI_means", "celltype_ASW", "celltype_ASW_means")

method = "uncorrected"
method.reduction <- "pca"
metricsObject <- object

integrationMetrics[[method]] <- getIntegrationMetrics(object=metricsObject,
                                                      metrics = useMetrics,
                                                      meta.label = meta.label,
                                                      meta.batch = meta.batch,
                                                      lisi_perplexity = lisi_perplexity,
                                                      method.reduction = method.reduction,
                                                      metricsLabels = metricsLabels)

```
Sanity Check
```{r}
lisi.test <- compute_lisi(
          object@reductions[[method.reduction]]@cell.embeddings,
          meta_data = object@meta.data,
          label_colnames = meta.batch,
          perplexity = lisi_perplexity
        )
head(lisi.test$batch)
lisi.test.norm <- (lisi.test-1)/(length(unique(object@meta.data[[meta.batch]]))-1)
head(lisi.test.norm$batch)

object$dummyGroup <- "dummyGroup"
lisi.splitBy.test <- compute_lisi_splitBy(
          object@reductions[[method.reduction]]@cell.embeddings,
          meta_data = object@meta.data,
          label_colnames = meta.batch,
          perplexity = lisi_perplexity,
          split_by_colname = "dummyGroup",
          normalize = T
        )
head(lisi.splitBy.test[["dummyGroup"]]$batch)

all.equal(lisi.test.norm$batch,lisi.splitBy.test[["dummyGroup"]]$batch)

```


Set up plot parameters
```{r}
plot.list <- list()
metricsShow.batch <- grep("batch",names(integrationMetrics[[1]]),value = T)
metricsShow.celltype <- grep("celltype",names(integrationMetrics[[1]]),value = T)
```

```{r}

plotIntegrationMetricsDim <- function(plot.list, metricsShow.batch, metricsShow.celltype, reduction="umap", plot=T){
  
  batch <- round(as.numeric(integrationMetrics[[method]][metricsShow.batch]),2)
  ctype <- round(as.numeric(integrationMetrics[[method]][metricsShow.celltype]),2)
  
  metricsShow.batch.caption <- paste(metricsShow.batch, batch, collapse = "\n ")
  
  metricsShow.celltype.caption <- paste(metricsShow.celltype, ctype, collapse = "\n ")
  
  plot.list[[method]][["batch"]] <- DimPlot(metricsObject,
                                            group.by = meta.batch,
                                            reduction = reduction) + 
    theme(aspect.ratio = 1) +
    labs(subtitle = "Dataset/batch", title = method, caption = metricsShow.batch.caption)
  
  plot.list[[method]][["label"]] <- DimPlot(metricsObject,
                                            group.by = meta.label,
                                            label=T,
                                            label.size = 4,
                                            reduction = reduction) + 
    theme(aspect.ratio = 1) +
    labs(subtitle = "Cell labels", title = method, caption = metricsShow.celltype.caption)
  
  
  if (plot) {
    a <- plot.list[[method]][["batch"]]
    b <- plot.list[[method]][["label"]]
    print(a | b)
  }
  return(plot.list)
  
} 

```



```{r fig.height=6, fig.width=6}
plot.list <- plotIntegrationMetricsDim(plot.list,
                                       metricsShow.batch,
                                       metricsShow.celltype)
```

Clusters are largely driven by cell subtypes, but within each subtype the effect of study/batch is visible in the UMAP


Let's repeat the previous task, but using HVGs that are consistently variable across datasets (shared dataset features)
We'll split by dataset/batch, calculate HVG for each, then identify shared genes using Seurat's SelectIntegrationFeatures

```{r}
obj.list <- SplitObject(object, split.by = meta.batch)
```

```{r message=F, warning=F,results=F, eval=T}

for (i in 1:length(obj.list)) {
  obj.list[[i]] <- NormalizeData(obj.list[[i]],assay="RNA",
                                 normalization.method="LogNormalize")
  obj.list[[i]] <- FindVariableFeatures(obj.list[[i]], nfeatures=nfeatures*2)
}

hvg <- SelectIntegrationFeatures(obj.list, nfeatures = nfeatures)
```

Re-calculate dimensionality reduction using `hvg`
```{r message=F, warning=F,results=F}
object@assays$RNA@var.features <- hvg
object <- ScaleData(object) %>% RunPCA(npcs=ndim) %>% RunUMAP(dims=1:ndim)
```

```{r}
method = "sharedFeatures"
method.reduction <- "pca"
metricsObject <- object

integrationMetrics[[method]] <- getIntegrationMetrics(object=metricsObject,
                                                      metrics = useMetrics,
                                                      meta.label = meta.label,
                                                      meta.batch = meta.batch,
                                                      lisi_perplexity = lisi_perplexity,
                                                      method.reduction = method.reduction,
                                                      metricsLabels = metricsLabels)
```

```{r fig.height=5, fig.width=5}
plot.list <- plotIntegrationMetricsDim(plot.list,
                                       metricsShow.batch,
                                       metricsShow.celltype)
```



# STACAS integration

```{r  message=F, warning=F,results=F}
object_integrated_stacas <- Run.STACAS(obj.list, dims = 1:ndim, anchor.features = hvg) %>%
      RunUMAP(dims = 1:ndim) 
```

```{r}
method = "STACAS"
method.reduction <- "pca"
metricsObject <- object_integrated_stacas

integrationMetrics[[method]] <- getIntegrationMetrics(object=metricsObject,
                                                      metrics = useMetrics,
                                                      meta.label = meta.label,
                                                      meta.batch = meta.batch,
                                                      lisi_perplexity = lisi_perplexity,
                                                      method.reduction = method.reduction,
                                                      metricsLabels = metricsLabels)

```

```{r fig.height=5, fig.width=5}
plot.list <- plotIntegrationMetricsDim(plot.list,
                                       metricsShow.batch,
                                       metricsShow.celltype)

```





# Semi-supervised STACAS integration

When available, cell type annotations can be used to guide the alignment. STACAS will use this information to penalize anchors where cell types are inconsistent.
In this dataset, cells were annotated by the authors of the benchmark. In practice we will partially annotate cells using tools such as [scGate](https://github.com/carmonalab/scGate)

Here we indicate in `cell.labels` the metadata column that contains cell annotations
```{r, results=F, warning=F, message=F }
object_integrated_ss <- obj.list %>% Run.STACAS(dims = 1:ndim, anchor.features=hvg,
                                                cell.labels = meta.label)
```


Note that there is no need for ALL cells to be annotated: we recommend to set labels to *NA* or *unknown* for cells that cannot be confidently annotated, and they won't be penalized for label inconsistency. In addition, you can decide how much weight to give to cell labels with the `label.confidence` parameter (from 0 to 1).

Visualize on UMAP space
```{r results=F, warning=F, message=F}
object_integrated_ss <- object_integrated_ss %>% RunUMAP(dims=1:ndim)
```

```{r}
method = "semisupSTACAS"
method.reduction <- "pca"
metricsObject <- object_integrated_ss

integrationMetrics[[method]] <- getIntegrationMetrics(object=metricsObject,
                                                      metrics = useMetrics,
                                                      meta.label = meta.label,
                                                      meta.batch = meta.batch,
                                                      lisi_perplexity = lisi_perplexity,
                                                      method.reduction = method.reduction,
                                                      metricsLabels = metricsLabels)
```

```{r fig.height=8, fig.width=16}
plot.list <- plotIntegrationMetricsDim(plot.list,
                                       metricsShow.batch,
                                       metricsShow.celltype)

```



# Seurat Integration - CCA method

```{r, results=F, warning=F, message=F, eval=T }

# find anchors
obj.list.seuratAnchors <- FindIntegrationAnchors(obj.list, anchor.features = hvg, reduction = "cca", dims = 1:ndim)

# integrate data
object_integrated_cca <- IntegrateData(anchorset = obj.list.seuratAnchors, dims=1:ndim)

rm(obj.list.seuratAnchors)
```

Visualize on UMAP space
```{r results=F, warning=F, message=F, eval=T}
object_integrated_cca <- object_integrated_cca %>% ScaleData() %>% RunPCA(npcs=ndim) %>% RunUMAP(dims=1:ndim)
```


```{r, eval=T}
method = "SEURAT_cca"
method.reduction <- "pca"
metricsObject <- object_integrated_cca

integrationMetrics[[method]] <- getIntegrationMetrics(object=metricsObject,
                                                      metrics = useMetrics,
                                                      meta.label = meta.label,
                                                      meta.batch = meta.batch,
                                                      lisi_perplexity = lisi_perplexity,
                                                      method.reduction = method.reduction,
                                                      metricsLabels = metricsLabels)

```

```{r fig.height=8, fig.width=16, eval=T}
plot.list <- plotIntegrationMetricsDim(plot.list,metricsShow.batch,metricsShow.celltype)

```



# Seurat Integration - RPCA method

```{r, results=F, warning=F, message=F }

# find anchors
obj.list.seuratAnchors <- FindIntegrationAnchors(obj.list, anchor.features = hvg,
                                                 reduction = "rpca", dims = 1:ndim)

# integrate data
object_integrated_rpca <- IntegrateData(anchorset = obj.list.seuratAnchors, dims=1:ndim)

rm(obj.list.seuratAnchors)
```

Visualize on UMAP space
```{r results=F, warning=F, message=F}

object_integrated_rpca <- object_integrated_rpca %>% ScaleData() %>% RunPCA(npcs=ndim) %>% RunUMAP(dims=1:ndim)
```

```{r}
method = "SEURAT_rpca"
method.reduction <- "pca"
metricsObject <- object_integrated_rpca

integrationMetrics[[method]] <- getIntegrationMetrics(object=metricsObject,
                                                      metrics = useMetrics,
                                                      meta.label = meta.label,
                                                      meta.batch = meta.batch,
                                                      lisi_perplexity = lisi_perplexity,
                                                      method.reduction = method.reduction,
                                                      metricsLabels = metricsLabels)

```

```{r fig.height=8, fig.width=16}
plot.list <- plotIntegrationMetricsDim(plot.list,metricsShow.batch,metricsShow.celltype)

```



# Harmony Integration

```{r message=F, warning=F,results=F}
object_integrated_harmony <- RunHarmony(object, group.by.vars =  meta.batch)
```

Visualize on UMAP space
```{r results=F, warning=F, message=F}
object_integrated_harmony <- RunUMAP(object_integrated_harmony, reduction = "harmony", dims=1:ndim)
```


```{r}
method = "Harmony"
method.reduction <- "harmony"
metricsObject <- object_integrated_harmony

integrationMetrics[[method]] <- getIntegrationMetrics(object=metricsObject,
                                                      metrics = useMetrics,
                                                      meta.label = meta.label,
                                                      meta.batch = meta.batch,
                                                      lisi_perplexity = lisi_perplexity,
                                                      method.reduction = method.reduction,
                                                      metricsLabels = metricsLabels)

```

```{r fig.height=8, fig.width=16}
plot.list <- plotIntegrationMetricsDim(plot.list,metricsShow.batch,metricsShow.celltype)

```


# FastMNN Integration

```{r  message=F, warning=F,results=F}
object_integrated_FastMNN <- RunFastMNN(object.list = obj.list, features = hvg, assay="RNA", d=ndim)
```

Visualize on UMAP space
```{r results=F, warning=F, message=F}
object_integrated_FastMNN <- RunUMAP(object_integrated_FastMNN, reduction = "mnn", dims=1:ndim)
```


```{r}
method = "FastMNN"
method.reduction <- "mnn"
metricsObject <- object_integrated_FastMNN

integrationMetrics[[method]] <- getIntegrationMetrics(object=metricsObject,
                                                      metrics = useMetrics,
                                                      meta.label = meta.label,
                                                      meta.batch = meta.batch,
                                                      lisi_perplexity = lisi_perplexity,
                                                      method.reduction = method.reduction,
                                                      metricsLabels = metricsLabels)

```

```{r fig.height=8, fig.width=16}
plot.list <- plotIntegrationMetricsDim(plot.list,metricsShow.batch,metricsShow.celltype)

```


# Summary of Integration Metrics

```{r, fig.height=8, fig.width=8}

integrationMetricsSummary <- data.frame(unlist(integrationMetrics)) %>% tibble::rownames_to_column() %>% dplyr::rename(value=unlist.integrationMetrics.) %>% separate(rowname, c("Method","Metric"), sep="\\.") #\\.[[:alpha:]]

ggplot(integrationMetricsSummary, aes(x=reorder_within(Method,-value, Metric),
                                      y=value, fill=Method)) + geom_bar(stat="identity") + 
    theme_bw() + 
    theme(legend.position="none", axis.text.x=element_text(angle = 90, vjust = 0.5, hjust=1)) +
  xlab("Dataset") + facet_wrap(~Metric, scales = "free")

```


```{r fig.height=20, fig.width=20}
p <- wrap_plots(lapply(plot.list,wrap_plots),ncol=2)
p & theme(legend.position = "none")
ggsave("compareMetrics.LueckenImmune.umap.png",p, width = 30, height = 30)
```


# Further reading

The STACAS package and installation instructions are available at: [STACAS package](https://github.com/carmonalab/STACAS)

The code for this demo can be found on [GitHub](https://github.com/carmonalab/STACAS.demo)

# References

* Andreatta A., Carmona S. J. (2021). *STACAS: Sub-Type Anchor Correction for Alignment in Seurat to integrate single-cell RNA-seq data.* - Bioinformatics

* Luecken, M. D., Büttner, M., Chaichoompu, K., Danese, A., Interlandi, M., Müller, M. F., ... & Theis, F. J. (2022). *Benchmarking atlas-level data integration in single-cell genomics.* - Nature methods

* Hao, Y., Hao, S., Andersen-Nissen, E., Mauck III, W. M., Zheng, S., Butler, A., ... & Satija, R. (2021). *Integrated analysis of multimodal single-cell data.* - Cell


